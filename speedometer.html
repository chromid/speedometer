<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="robots" content="noindex, nofollow, noarchive, nosnippet"><title>Speedometer</title><style> body { margin: 0; padding: 0; font-family: 'Segoe UI', 'Roboto', Helvetica, Arial, sans-serif; background-color: #000; color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; overflow: hidden; } .container { text-align: center; width: 100%; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; } .speed-display { font-size: 30vmin; font-weight: 300; line-height: 1; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; } .unit { font-size: 5vmin; opacity: 0.8; } .settings { position: absolute; bottom: 10vh; display: flex; justify-content: center; gap: 20px; width: 100%; } .unit-selector, .accuracy-selector { background-color: transparent; color: #fff; border: 1px solid transparent; padding: 8px 15px; font-size: 1rem; border-radius: 4px; cursor: pointer; transition: all 0.3s ease; } .unit-selector:hover, .accuracy-selector:hover, .unit-selector:focus, .accuracy-selector:focus { background-color: rgba(50, 50, 50, 0.8); border-color: rgba(255, 255, 255, 0.4); outline: none; } .unit-selector option, .accuracy-selector option { background-color: #222; } .status { position: absolute; bottom: 5vh; font-size: 0.9rem; opacity: 0.5; } .error { position: absolute; bottom: 2vh; color: #ff4545; opacity: 0.8; } </style></head><body><div class="container"><div class="speed-display"><span id="speed">−</span><span class="unit" id="unit-display">km/h</span></div><div id="status" class="status">Initializing…</div><div id="error" class="error"></div><div class="settings"><select id="unit-selector" class="unit-selector"><option value="kmh">km/h</option><option value="ms">m/s</option><option value="mph">mph</option></select><select id="accuracy-selector" class="accuracy-selector"><option value="low">Low speeds</option><option value="high">High speeds</option></select></div></div><script> const speedElement = document.getElementById('speed'); const unitDisplay = document.getElementById('unit-display'); const unitSelector = document.getElementById('unit-selector'); const accuracySelector = document.getElementById('accuracy-selector'); const statusElement = document.getElementById('status'); const errorElement = document.getElementById('error'); let watchId = null; let lastPositions = []; let currentUnit = 'kmh'; let accuracyMode = 'low'; let useDeviceSensors = false; let accelSupported = false; const UPDATE_INTERVAL = 500; const MAX_POSITIONS = 3; const LOW_SPEED_MAX_POSITIONS = 5; if (window.DeviceMotionEvent) { try { if (typeof DeviceMotionEvent.requestPermission === 'function') { document.body.addEventListener('click', async () => { try { const permission = await DeviceMotionEvent.requestPermission(); if (permission === 'granted') { initAccelerometer(); } } catch (e) { console.error('Error accessing accelerometer:', e); } }, { once: true }); } else { initAccelerometer(); } } catch (e) { console.error('Error initializing accelerometer:', e); } } function initAccelerometer() { accelSupported = true; window.addEventListener('devicemotion', handleMotionEvent, false); statusElement.textContent = 'Accelerometer available'; if (accuracyMode === 'low') { useDeviceSensors = true; } } let lastAccelTime = 0; let currentSpeed = 0; let accelReadings = []; const ACCEL_BUFFER_SIZE = 5; let isMoving = false; let movementThreshold = 0.8; let lastVelocity = { x: 0, y: 0, z: 0 }; function handleMotionEvent(event) { if (!(accuracyMode === 'low' && useDeviceSensors)) return; const accel = event.acceleration; if (!accel || accel.x === null) return; const now = Date.now(); if (lastAccelTime === 0) { lastAccelTime = now; return; } const dt = (now - lastAccelTime) / 1000; lastAccelTime = now; const accelMagnitude = Math.sqrt(accel.x * accel.x + accel.y * accel.y + accel.z * accel.z); accelReadings.push(accelMagnitude); if (accelReadings.length > ACCEL_BUFFER_SIZE) { accelReadings.shift(); } const avgAcceleration = accelReadings.reduce((sum, val) => sum + val, 0) / accelReadings.length; isMoving = avgAcceleration > movementThreshold; if (isMoving) { lastVelocity.x += accel.x * dt; lastVelocity.y += accel.y * dt; lastVelocity.z += accel.z * dt; const accelSpeed = Math.sqrt( lastVelocity.x * lastVelocity.x + lastVelocity.y * lastVelocity.y + lastVelocity.z * lastVelocity.z ); currentSpeed = currentSpeed * 0.7 + accelSpeed * 0.3; const hasRecentGPS = lastPositions.length > 0 && (now - lastPositions[lastPositions.length-1].timestamp) < 2000; if (hasRecentGPS && lastPositions[lastPositions.length-1].speed !== null) { const gpsSpeed = lastPositions[lastPositions.length-1].speed; currentSpeed = gpsSpeed; const factor = gpsSpeed / (accelSpeed || 1); lastVelocity.x *= factor; lastVelocity.y *= factor; lastVelocity.z *= factor; } if (lastPositions.length === 0 || lastPositions[lastPositions.length-1].speed === null) { const now = Date.now(); if (lastPositions.length > 0) { const virtualPosition = { ...lastPositions[lastPositions.length-1], speed: currentSpeed, timestamp: now }; lastPositions.push(virtualPosition); if (lastPositions.length > LOW_SPEED_MAX_POSITIONS) { lastPositions.shift(); } calculateSpeed(); } } } else { if (currentSpeed > 0.1) { currentSpeed *= 0.9; if (currentSpeed < 0.1) currentSpeed = 0; lastVelocity.x *= 0.9; lastVelocity.y *= 0.9; lastVelocity.z *= 0.9; } } if (isMoving) { statusElement.textContent = `Low speed mode - Motion detected (${avgAcceleration.toFixed(2)} m/s²)`; } } function initGeolocation() { if ('geolocation' in navigator) { statusElement.textContent = 'Requesting geolocation access…'; const geoOptions = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }; try { watchId = navigator.geolocation.watchPosition( handlePosition, handleError, geoOptions ); statusElement.textContent = 'Measurement active'; } catch (e) { errorElement.textContent = `Geolocation initialization error: ${e.message}`; } } else { errorElement.textContent = 'Geolocation is not supported by this browser'; } } function handlePosition(position) { const currentPosition = { lat: position.coords.latitude, lng: position.coords.longitude, accuracy: position.coords.accuracy, speed: position.coords.speed, timestamp: position.timestamp }; lastPositions.push(currentPosition); const maxPositions = accuracyMode === 'low' ? LOW_SPEED_MAX_POSITIONS : MAX_POSITIONS; if (lastPositions.length > maxPositions) { lastPositions.shift(); } calculateSpeed(); } function handleError(error) { let errorMessage = ''; switch(error.code) { case error.PERMISSION_DENIED: errorMessage = 'Geolocation permission denied'; break; case error.POSITION_UNAVAILABLE: errorMessage = 'Position information is unavailable'; break; case error.TIMEOUT: errorMessage = 'Position request timed out'; break; default: errorMessage = `Unknown error: ${error.message}`; } errorElement.textContent = errorMessage; } function calculateSpeed() { let speed = 0; if (lastPositions.length < 2) { if (lastPositions.length > 0 && lastPositions[lastPositions.length-1].speed !== null) { speed = lastPositions[lastPositions.length-1].speed || 0; } } else { if (accuracyMode === 'low') { let validSpeedCount = 0; let totalSpeed = 0; for (let i = 0; i < lastPositions.length; i++) { if (lastPositions[i].speed !== null) { totalSpeed += lastPositions[i].speed; validSpeedCount++; } } if (validSpeedCount > 0) { speed = totalSpeed / validSpeedCount; } else { speed = calculateSpeedFromPositions(); } } else { if (lastPositions[lastPositions.length-1].speed !== null) { speed = lastPositions[lastPositions.length-1].speed; } else { speed = calculateSpeedFromPositions(); } } } displaySpeed(speed); } function calculateSpeedFromPositions() { const sortedPositions = [...lastPositions].sort((a, b) => a.timestamp - b.timestamp); const oldest = sortedPositions[0]; const newest = sortedPositions[sortedPositions.length - 1]; const distance = calculateDistance( oldest.lat, oldest.lng, newest.lat, newest.lng ); const timeSeconds = (newest.timestamp - oldest.timestamp) / 1000; return timeSeconds > 0 ? distance / timeSeconds : 0; } function calculateDistance(lat1, lon1, lat2, lon2) { const R = 6371e3; const φ1 = lat1 * Math.PI / 180; const φ2 = lat2 * Math.PI / 180; const Δφ = (lat2 - lat1) * Math.PI / 180; const Δλ = (lon2 - lon1) * Math.PI / 180; const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R * c; } function displaySpeed(speedInMetersPerSecond) { let displaySpeed = 0; switch (currentUnit) { case 'kmh': displaySpeed = speedInMetersPerSecond * 3.6; unitDisplay.textContent = 'km/h'; break; case 'ms': displaySpeed = speedInMetersPerSecond; unitDisplay.textContent = 'm/s'; break; case 'mph': displaySpeed = speedInMetersPerSecond * 2.23694; unitDisplay.textContent = 'mph'; break; } displaySpeed = Math.max(0, displaySpeed); speedElement.textContent = displaySpeed.toLocaleString('sv-SE', { maximumFractionDigits: 2 }); } unitSelector.addEventListener('change', function() { currentUnit = this.value; calculateSpeed(); }); accuracySelector.addEventListener('change', function() { accuracyMode = this.value; if (accuracyMode === 'low') { useDeviceSensors = accelSupported; statusElement.textContent = 'Low speed mode'; } else { useDeviceSensors = false; statusElement.textContent = 'High speed mode'; } lastPositions = []; }); window.addEventListener('load', function() { initGeolocation(); });</script></body></html>
